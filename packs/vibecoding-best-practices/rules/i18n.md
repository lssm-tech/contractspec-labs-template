---
targets:
  - '*'
root: false
description: 'Internationalization governance — translation patterns, copy conventions, and locale compliance'
globs:
  - '**/*'
cursor:
  alwaysApply: true
  description: 'Internationalization governance — translation patterns, copy conventions, and locale compliance'
  globs:
    - '**/*'
---

# Internationalization (i18n)

"Every user-facing string must be translatable. No hardcoded English in presentation code. The i18n system is custom — follow the established patterns exactly."

## Core Principles

- **No hardcoded user-facing strings**: All text visible to users (labels, headings, buttons, messages, errors, tooltips, placeholders) must go through the i18n system.
- **Two translation patterns**: Use the correct pattern for the context (key-based vs copy-based).
- **All 3 locales populated**: Every translation entry must include `en`, `fr`, and `es`. English is always the fallback.
- **Type-safe copy**: All copy is typed with TypeScript interfaces — never use untyped `Record<string, string>`.

---

## Supported Locales

| Code | Language | Status             |
| ---- | -------- | ------------------ |
| `en` | English  | Default / fallback |
| `fr` | French   | Required           |
| `es` | Spanish  | Required           |

Defined in: `packages/libs/contracts-contractspec-studio/src/i18n/types.ts`

Core types:

```typescript
type AppLocale = 'en' | 'fr' | 'es';
const APP_SUPPORTED_LOCALES = ['en', 'fr', 'es'] as const;
const APP_DEFAULT_LOCALE: AppLocale = 'en';
```

Use `isAppLocale()` to validate and `normalizeAppLocale()` to normalize (handles region subtags like `fr-CA` -> `fr`).

---

## Two Translation Patterns

### Pattern 1: Key-Based (App Shell Strings)

**When to use**: For shared, cross-feature strings (navigation, auth, common UI chrome, generic error messages, generic buttons).

**How it works**:

1. Add a key to `APP_MESSAGE_KEYS` in `packages/libs/contracts-contractspec-studio/src/i18n/messages.ts`
2. Add the value to `appMessagesEn`, `appMessagesFr`, and `appMessagesEs`
3. Consume via `useAppI18n().t(APP_MESSAGE_KEYS.MY_KEY)` or `translateAppMessage(key, locale)`

```typescript
// In messages.ts
const APP_MESSAGE_KEYS = {
  SAVE_BUTTON: 'common.save',
  // ...
} as const;

// In appMessagesEn
messages: {
  [APP_MESSAGE_KEYS.SAVE_BUTTON]: { value: 'Save' },
}

// In component
const { t } = useAppI18n();
return <Button>{t(APP_MESSAGE_KEYS.SAVE_BUTTON)}</Button>;
```

**Supports interpolation**: `{placeholder}` tokens in values, passed as `params`:

```typescript
t(APP_MESSAGE_KEYS.WELCOME, { name: user.name });
// value: "Welcome, {name}!" -> "Welcome, Alice!"
```

### Pattern 2: Copy-Based (Feature/Domain Copy)

**When to use**: For feature-specific strings, marketing pages, or any domain with structured multi-field copy.

**How it works**:

1. Define a TypeScript interface for the copy shape
2. Create a `Record<AppLocale, CopyType>` constant with all 3 locales
3. Export a getter function with English fallback
4. Consume via `getCopy(locale)`

```typescript
// feature-copy.ts

export interface FeatureCopy {
  title: string;
  description: string;
  emptyState: string;
  errorMessage: string;
}

const FEATURE_COPY: Record<AppLocale, FeatureCopy> = {
  en: {
    title: 'My Feature',
    description: 'This does something useful.',
    emptyState: 'No items yet.',
    errorMessage: 'Failed to load.',
  },
  fr: {
    title: 'Ma Fonctionnalite',
    description: "Cela fait quelque chose d'utile.",
    emptyState: 'Aucun element pour le moment.',
    errorMessage: 'Echec du chargement.',
  },
  es: {
    title: 'Mi Funcionalidad',
    description: 'Esto hace algo util.',
    emptyState: 'No hay elementos todavia.',
    errorMessage: 'Error al cargar.',
  },
};

export function getFeatureCopy(locale: AppLocale): FeatureCopy {
  return FEATURE_COPY[locale] ?? FEATURE_COPY.en;
}
```

**For large copy files** (>250 lines): Split into per-locale files:

```
feature-copy.types.ts    # Interface definition
feature-copy.en.ts       # English copy
feature-copy.fr.ts       # French copy
feature-copy.es.ts       # Spanish copy
feature-copy.ts          # Assembles Record + exports getter
```

---

## Where Copy Files Live

| Copy type                | Location                                                                                    |
| ------------------------ | ------------------------------------------------------------------------------------------- |
| Shared / cross-feature   | `packages/libs/contracts-contractspec-studio/src/i18n/`                                     |
| Feature-domain copy      | `packages/libs/contracts-contractspec-studio/src/i18n/<domain>-copy/` or `<domain>-copy.ts` |
| Marketing page copy      | Co-located with the page: `packages/apps/web-marketing/src/app/[locale]/.../<page>-copy.ts` |
| Bundle presentation copy | In the bundle under a relevant module or i18n directory                                     |

**Barrel exports**: All copy getters and types from the contracts i18n module must be re-exported from `packages/libs/contracts-contractspec-studio/src/i18n/index.ts`.

---

## Consumption Hooks

| Context           | Hook                                                  | What it provides                                             |
| ----------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| Web application   | `useAppI18n()` from `@/lib/i18n/provider`             | `{ locale, t }` — React context-based                        |
| Bundle components | `useAppI18n()` from `presentation/hooks/use-app-i18n` | `{ locale, t }` — reads `document.documentElement.lang`      |
| Marketing         | `useMarketingI18n()` from `@/lib/i18n/provider`       | `{ locale }` — context-based, use `getCopy(locale)` directly |

**Never do**:

```tsx
// BAD: hardcoded English
<Button>Save changes</Button>
<p>No results found</p>
<ErrorState message="Something went wrong" />

// BAD: raw string comparison for locale
if (locale === 'fr') { ... }
```

**Always do**:

```tsx
// GOOD: key-based (app shell)
const { t } = useAppI18n();
<Button>{t(APP_MESSAGE_KEYS.SAVE)}</Button>

// GOOD: copy-based (feature)
const { locale } = useAppI18n();
const copy = getFeatureCopy(locale);
<p>{copy.emptyState}</p>
<ErrorState message={copy.errorMessage} />

// GOOD: type-safe locale check
if (isAppLocale(value)) { ... }
```

---

## What Must Be Translated

**Required** (user-facing strings in UI):

- Button labels and CTAs
- Headings and titles
- Body text and descriptions
- Error messages shown to users
- Empty state messages
- Loading state text
- Form labels, placeholders, and validation messages
- Tooltip content
- Modal/dialog titles and descriptions
- Notification/toast messages
- Navigation items and menu labels

**Exempt** (technical / non-user-facing):

- CSS class names, `data-*` attributes, `aria-*` attributes
- Analytics event names and property keys
- Log messages (server-side structured logging)
- Code identifiers, enum values, API field names
- URLs and email addresses
- Single punctuation/icon characters
- Test fixtures and mock data

---

## Naming Conventions

**Copy file naming**:

- Feature copy: `<feature>-copy.ts` (e.g., `billing-copy.ts`, `focus-copy.ts`)
- Per-locale split: `<feature>-copy.en.ts`, `<feature>-copy.fr.ts`, `<feature>-copy.es.ts`
- Types file: `<feature>-copy.types.ts` or interface defined in the same file

**Getter function naming**:

- Pattern: `get<Feature>Copy(locale: AppLocale): <Feature>Copy`
- Examples: `getBillingCopy()`, `getFocusCardCopy()`, `getPricingFaqCopy()`

**Message key naming** (key-based pattern):

- Dot-separated path: `<domain>.<element>.<variant>`
- Examples: `common.save`, `auth.login.title`, `error.generic.message`
- Constants: `UPPER_SNAKE_CASE` in `APP_MESSAGE_KEYS`

---

## Adding a New Locale

Checklist when adding a 4th+ locale:

1. Add to `APP_SUPPORTED_LOCALES` in `types.ts`
2. Add `AppLocale` type will auto-expand (union from const array)
3. Add locale entry to `appMessages<Locale>` in `messages.ts`
4. Register the new spec in `registry.ts` (`APP_I18N_REGISTRY`)
5. Add `getLocaleDisplayName` mapping in `registry.ts`
6. Add `getLlmOutputLanguageInstruction` mapping in `registry.ts`
7. Update every `Record<AppLocale, ...>` copy constant (TypeScript will flag missing entries)
8. Update marketing `[locale]` route `generateStaticParams()`
9. Update locale hydrator and request-locale fallback chains
10. Run `/audit-i18n` to verify completeness

---

## ESLint Enforcement

The project includes `eslint-plugin-i18next` with the `i18next/no-literal-string` rule:

- **Global config** (`eslint.config.js`): Rule is **WARN** for three presentation surfaces (caught by `turbo lint`):
  - `packages/apps/web-application/src/**/*.tsx`
  - `packages/bundles/**/src/presentation/**/*.tsx`
  - `packages/apps/web-marketing/src/**/*.tsx`
- **i18n config** (`eslint.config.i18n.js`): Rule is ERROR for `packages/apps/web-application/src/**` in `jsx-text-only` mode (stricter standalone check)

The rule uses `jsx-text-only` mode with `markupOnly: true`, catching:

- Literal strings in JSX text content (`<p>Hello</p>`)
- Ignores: `className`, `data-*`, `aria-*`, `id`, `href`, `src`, `role`, `alt`, `title`, `type`, `name`, `target`, `rel`, `htmlFor`, `autoComplete`, `inputMode` attributes

**Severity ladder**: The main config uses `warn` to give visibility without blocking CI. The standalone `eslint.config.i18n.js` uses `error` for stricter enforcement. The intent is to escalate from `warn` -> `error` once existing violations are remediated.

---

## Dev Heuristics

✅ Is every user-facing string going through `t()` or `getCopy(locale)`?
✅ Does the copy file include all 3 locales (en, fr, es)?
✅ Is the copy typed with a TypeScript interface?
✅ Does the getter function fall back to English?
✅ Is the getter exported from the i18n barrel `index.ts`?
✅ Is the copy file under 250 lines? If not, split per-locale.
✅ Am I using the correct pattern (key-based for shell, copy-based for features)?
❌ Am I hardcoding English text in JSX? -> Extract to copy file.
❌ Am I using `Record<string, string>` for copy? -> Use a typed interface.
❌ Am I adding a key without all 3 locale values? -> Complete all locales before merging.

---

## Tooling

- **Audit**: Run `/audit-i18n` to scan for missing translations, hardcoded strings, and pattern violations.
- **Create**: Use the `add-i18n-copy` skill to scaffold new copy files following the established pattern.
- **Hook**: The `post-edit-checks` hook warns when presentation files are edited without i18n compliance.
- **Lint**: `turbo lint` now warns on hardcoded JSX text in all three presentation surfaces. The standalone `eslint.config.i18n.js` enforces errors for stricter checks.

## References

- See `frontend.md` for component patterns and UI structure
- See `code-splitting.md` for file size limits (applies to copy files too)
- See `code-quality-practices.md` for naming conventions
- See `package-architecture.md` for where copy files should live
